# Lecture 05

## 08:00-09:00

这一部分我没到。我不是很清楚讲了什么。后面摘了一些东西。

我们需要　$\frac{n}{\log{n}}$ processors 和　$\frac{n}{p}+\log{n}$ time。

Pack: $\frac{n}{p} + \log{n}$。

这个算法用于初步缩减 n 的数量使之小于　$n\log{n}$。
这样我们之后就可以用　pointer jumping。

这里我们说的高度为其格数，然后其　weight 为 1, 2, 4, 8...
然后我们就可以证明经过一次　round，总 weight 至少减少　$\frac{1}{4}$。

由于　$weight > 1$，所以必然有　$node.length > \sum{weight}$。

## Bitonic Merging

假设我们有两个**排好序**的数列，他们方向相反，我们把他们接起来

$$
2 - 5 - 7 - 8 - 10
$$

$$
12 - 4 - 0
$$

然后二分

$$
\begin{xy}
\xymatrix {
      2 \ar@/^2pc/ [rrrrr]
    & 5 \ar@/^2pc/ [rrrrr]
    & 7 \ar@/^2pc/ [rrrrr]
    & 8 \ar@/^2pc/ [rrrrr]
    & |
    & 10
    & 12
    & 4
    & 0 \ar
}
\end{xy}
$$

交换，将小数置前

$$
\begin{xy}
\xymatrix {
      2
    & 5
    & 4
    & 0
    & |
    & 10
    & 12
    & 7
    & 8
}
\end{xy}
$$

再对半分

$$
\begin{xy}
\xymatrix {
      2 \ar@/^2pc/ [rrr]
    & 5 \ar@/^2pc/ [rrr]
    & |
    & 4
    & 0
    & |
    & 10 \ar@/^2pc/ [rrr]
    & 12 \ar@/^2pc/ [rrr]
    & |
    & 7
    & 8
}
\end{xy}
$$

交换，将小数置前

$$
\begin{xy}
\xymatrix {
      2
    & 0
    & 4
    & 5
    & 7
    & 8
    & 10
    & 12
}
\end{xy}
$$

再二分

$$
\begin{xy}
\xymatrix {
      2 \ar@/^2pc/ [r]
    & 0
    & 4 \ar@/^2pc/ [r]
    & 5
    & 7 \ar@/^2pc/ [r]
    & 8
    & 10 \ar@/^2pc/ [r]
    & 12
}
\end{xy}
$$

交换，将小数置前，这就是我们最终 merge 的结果了

$$
\begin{xy}
\xymatrix {
      0
    & 2
    & 4
    & 5
    & 7
    & 8
    & 10
    & 12
}
\end{xy}
$$

我们需要 $\log{n}$ steps，然后时间复杂度为 $O(\frac{n}{p}\log{n}+\log{n})$。

## Bitonic Sorting

假设我们有这个数组需要排序。

$$
\begin{xy}
\xymatrix {
      7 \ar@/^2pc/ [r]
    & 5
    & 4 \ar@/^2pc/ [r]
    & 3
    & 8 \ar@/^2pc/ [r]
    & 6
    & 2 \ar@/^2pc/ [r]
    & 1
}
\end{xy}
$$

我们将对象分为４组，每组我们将左边当成是一个数列，右边当成一个数列，我们做　Bitonic Merging。
这样我们得到了：

$$
5 - 7 - | - 3 - 4 - || - 6 - 8 - | - 1 - 2
$$

然后我们将对象分为 2 组，每组我们将左边两个数当成一个数列，右边两个数当成一个数列。
我们再做　Bitonic Merging。

这样有了：

$$
3 - 4 - 5 - 7 - | - 1 - 2 - 6 - 8
$$

我们再做一次　Bitonic Merging，
就得到了 Sorting 的结果。

Bitonic Sorting 的时间复杂度为：$O(\frac{n}{p}\log^2{n}+\log^2{n})$。

Hint: 如果需要简单的估算复杂度，可以直接取中间一段的最小值然后乘以那一段的 steps 作为下界。
对于上界，可以用最大复杂度乘以总体的 steps。

## Valiant's Merging

时间复杂度为：$O(\frac{n}{p}\log\log{n} + \log\log{n})$

## Valiant's Sorting

就是将利用之前 Bitonic Sorting 所述的方法，将 Merging 转换为 Sorting。

时间复杂度为：$O(\frac{n}{p}\log{n}\log\log{n} + \log{n}\log\log{n})$
